// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subscriptions.sql

package wood

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO app.subscriptions
(customer_id, plan_name, quantity_tonnes, flat_rate_cents, delivery_month, status, next_delivery_date, start_date, stripe_subscription_id, config)
VALUES
($1::uuid, $2, $3, $4, $5, $6::app.subscription_status,
 $7, $8, $9, COALESCE($10::jsonb, '{}'::jsonb))
RETURNING subscription_id, customer_id, plan_name, quantity_tonnes, flat_rate_cents, delivery_month, status, next_delivery_date, start_date, end_date, stripe_subscription_id, config, is_enabled, created_at, updated_at
`

type CreateSubscriptionParams struct {
	CustomerID           uuid.UUID             `db:"customer_id" json:"customerId"`
	PlanName             string                `db:"plan_name" json:"planName"`
	QuantityTonnes       string                `db:"quantity_tonnes" json:"quantityTonnes"`
	FlatRateCents        int64                 `db:"flat_rate_cents" json:"flatRateCents"`
	DeliveryMonth        int32                 `db:"delivery_month" json:"deliveryMonth"`
	Status               AppSubscriptionStatus `db:"status" json:"status"`
	NextDeliveryDate     sql.NullTime          `db:"next_delivery_date" json:"nextDeliveryDate"`
	StartDate            time.Time             `db:"start_date" json:"startDate"`
	StripeSubscriptionID sql.NullString        `db:"stripe_subscription_id" json:"stripeSubscriptionId"`
	Config               json.RawMessage       `db:"config" json:"config"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (AppSubscription, error) {
	row := q.db.QueryRowContext(ctx, createSubscription,
		arg.CustomerID,
		arg.PlanName,
		arg.QuantityTonnes,
		arg.FlatRateCents,
		arg.DeliveryMonth,
		arg.Status,
		arg.NextDeliveryDate,
		arg.StartDate,
		arg.StripeSubscriptionID,
		arg.Config,
	)
	var i AppSubscription
	err := row.Scan(
		&i.SubscriptionID,
		&i.CustomerID,
		&i.PlanName,
		&i.QuantityTonnes,
		&i.FlatRateCents,
		&i.DeliveryMonth,
		&i.Status,
		&i.NextDeliveryDate,
		&i.StartDate,
		&i.EndDate,
		&i.StripeSubscriptionID,
		&i.Config,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSubscription = `-- name: DeleteSubscription :exec
DELETE FROM app.subscriptions
WHERE subscription_id = $1::uuid
`

func (q *Queries) DeleteSubscription(ctx context.Context, subscriptionID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteSubscription, subscriptionID)
	return err
}

const getSubscription = `-- name: GetSubscription :one
SELECT subscription_id, customer_id, plan_name, quantity_tonnes, flat_rate_cents, delivery_month, status, next_delivery_date, start_date, end_date, stripe_subscription_id, config, is_enabled, created_at, updated_at FROM app.subscriptions
WHERE subscription_id = $1::uuid
`

func (q *Queries) GetSubscription(ctx context.Context, subscriptionID uuid.UUID) (AppSubscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscription, subscriptionID)
	var i AppSubscription
	err := row.Scan(
		&i.SubscriptionID,
		&i.CustomerID,
		&i.PlanName,
		&i.QuantityTonnes,
		&i.FlatRateCents,
		&i.DeliveryMonth,
		&i.Status,
		&i.NextDeliveryDate,
		&i.StartDate,
		&i.EndDate,
		&i.StripeSubscriptionID,
		&i.Config,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSubscriptionsByCustomer = `-- name: ListSubscriptionsByCustomer :many
SELECT subscription_id, customer_id, plan_name, quantity_tonnes, flat_rate_cents, delivery_month, status, next_delivery_date, start_date, end_date, stripe_subscription_id, config, is_enabled, created_at, updated_at FROM app.subscriptions
WHERE customer_id = $1::uuid
ORDER BY created_at DESC
`

func (q *Queries) ListSubscriptionsByCustomer(ctx context.Context, customerID uuid.UUID) ([]AppSubscription, error) {
	rows, err := q.db.QueryContext(ctx, listSubscriptionsByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppSubscription
	for rows.Next() {
		var i AppSubscription
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.CustomerID,
			&i.PlanName,
			&i.QuantityTonnes,
			&i.FlatRateCents,
			&i.DeliveryMonth,
			&i.Status,
			&i.NextDeliveryDate,
			&i.StartDate,
			&i.EndDate,
			&i.StripeSubscriptionID,
			&i.Config,
			&i.IsEnabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscription = `-- name: UpdateSubscription :one
UPDATE app.subscriptions
SET plan_name = $1,
    quantity_tonnes = $2,
    flat_rate_cents = $3,
    delivery_month = $4,
    status = $5::app.subscription_status,
    next_delivery_date = $6,
    end_date = $7,
    stripe_subscription_id = $8,
    config = COALESCE($9::jsonb, config)
WHERE subscription_id = $10::uuid
RETURNING subscription_id, customer_id, plan_name, quantity_tonnes, flat_rate_cents, delivery_month, status, next_delivery_date, start_date, end_date, stripe_subscription_id, config, is_enabled, created_at, updated_at
`

type UpdateSubscriptionParams struct {
	PlanName             string                `db:"plan_name" json:"planName"`
	QuantityTonnes       string                `db:"quantity_tonnes" json:"quantityTonnes"`
	FlatRateCents        int64                 `db:"flat_rate_cents" json:"flatRateCents"`
	DeliveryMonth        int32                 `db:"delivery_month" json:"deliveryMonth"`
	Status               AppSubscriptionStatus `db:"status" json:"status"`
	NextDeliveryDate     sql.NullTime          `db:"next_delivery_date" json:"nextDeliveryDate"`
	EndDate              sql.NullTime          `db:"end_date" json:"endDate"`
	StripeSubscriptionID sql.NullString        `db:"stripe_subscription_id" json:"stripeSubscriptionId"`
	Config               json.RawMessage       `db:"config" json:"config"`
	SubscriptionID       uuid.UUID             `db:"subscription_id" json:"subscriptionId"`
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) (AppSubscription, error) {
	row := q.db.QueryRowContext(ctx, updateSubscription,
		arg.PlanName,
		arg.QuantityTonnes,
		arg.FlatRateCents,
		arg.DeliveryMonth,
		arg.Status,
		arg.NextDeliveryDate,
		arg.EndDate,
		arg.StripeSubscriptionID,
		arg.Config,
		arg.SubscriptionID,
	)
	var i AppSubscription
	err := row.Scan(
		&i.SubscriptionID,
		&i.CustomerID,
		&i.PlanName,
		&i.QuantityTonnes,
		&i.FlatRateCents,
		&i.DeliveryMonth,
		&i.Status,
		&i.NextDeliveryDate,
		&i.StartDate,
		&i.EndDate,
		&i.StripeSubscriptionID,
		&i.Config,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
