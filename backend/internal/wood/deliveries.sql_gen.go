// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: deliveries.sql

package wood

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const completeDelivery = `-- name: CompleteDelivery :one
UPDATE app.deliveries
SET status = 'completed',
    delivered_at = now(),
    quantity_tonnes = COALESCE($1, quantity_tonnes),
    notes = COALESCE($2, notes)
WHERE delivery_id = $3::uuid
RETURNING delivery_id, subscription_id, scheduled_date, delivered_at, status, quantity_tonnes, base_cost_cents, delivery_hours, stacking_hours, delivery_fee_cents, stacking_fee_cents, total_cost_cents, notes, created_at, updated_at
`

type CompleteDeliveryParams struct {
	QuantityTonnes sql.NullString `db:"quantity_tonnes" json:"quantityTonnes"`
	Notes          sql.NullString `db:"notes" json:"notes"`
	DeliveryID     uuid.UUID      `db:"delivery_id" json:"deliveryId"`
}

func (q *Queries) CompleteDelivery(ctx context.Context, arg CompleteDeliveryParams) (AppDelivery, error) {
	row := q.db.QueryRowContext(ctx, completeDelivery, arg.QuantityTonnes, arg.Notes, arg.DeliveryID)
	var i AppDelivery
	err := row.Scan(
		&i.DeliveryID,
		&i.SubscriptionID,
		&i.ScheduledDate,
		&i.DeliveredAt,
		&i.Status,
		&i.QuantityTonnes,
		&i.BaseCostCents,
		&i.DeliveryHours,
		&i.StackingHours,
		&i.DeliveryFeeCents,
		&i.StackingFeeCents,
		&i.TotalCostCents,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDelivery = `-- name: CreateDelivery :one
INSERT INTO app.deliveries
(subscription_id, scheduled_date, status, quantity_tonnes, notes)
VALUES ($1::uuid, $2, $3::app.delivery_status, $4, $5)
RETURNING delivery_id, subscription_id, scheduled_date, delivered_at, status, quantity_tonnes, base_cost_cents, delivery_hours, stacking_hours, delivery_fee_cents, stacking_fee_cents, total_cost_cents, notes, created_at, updated_at
`

type CreateDeliveryParams struct {
	SubscriptionID uuid.UUID         `db:"subscription_id" json:"subscriptionId"`
	ScheduledDate  time.Time         `db:"scheduled_date" json:"scheduledDate"`
	Status         AppDeliveryStatus `db:"status" json:"status"`
	QuantityTonnes sql.NullString    `db:"quantity_tonnes" json:"quantityTonnes"`
	Notes          sql.NullString    `db:"notes" json:"notes"`
}

func (q *Queries) CreateDelivery(ctx context.Context, arg CreateDeliveryParams) (AppDelivery, error) {
	row := q.db.QueryRowContext(ctx, createDelivery,
		arg.SubscriptionID,
		arg.ScheduledDate,
		arg.Status,
		arg.QuantityTonnes,
		arg.Notes,
	)
	var i AppDelivery
	err := row.Scan(
		&i.DeliveryID,
		&i.SubscriptionID,
		&i.ScheduledDate,
		&i.DeliveredAt,
		&i.Status,
		&i.QuantityTonnes,
		&i.BaseCostCents,
		&i.DeliveryHours,
		&i.StackingHours,
		&i.DeliveryFeeCents,
		&i.StackingFeeCents,
		&i.TotalCostCents,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDeliveriesBySubscription = `-- name: ListDeliveriesBySubscription :many
SELECT delivery_id, subscription_id, scheduled_date, delivered_at, status, quantity_tonnes, base_cost_cents, delivery_hours, stacking_hours, delivery_fee_cents, stacking_fee_cents, total_cost_cents, notes, created_at, updated_at FROM app.deliveries
WHERE subscription_id = $1::uuid
ORDER BY scheduled_date DESC
`

func (q *Queries) ListDeliveriesBySubscription(ctx context.Context, subscriptionID uuid.UUID) ([]AppDelivery, error) {
	rows, err := q.db.QueryContext(ctx, listDeliveriesBySubscription, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppDelivery
	for rows.Next() {
		var i AppDelivery
		if err := rows.Scan(
			&i.DeliveryID,
			&i.SubscriptionID,
			&i.ScheduledDate,
			&i.DeliveredAt,
			&i.Status,
			&i.QuantityTonnes,
			&i.BaseCostCents,
			&i.DeliveryHours,
			&i.StackingHours,
			&i.DeliveryFeeCents,
			&i.StackingFeeCents,
			&i.TotalCostCents,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
