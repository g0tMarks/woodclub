// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payments.sql

package wood

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createPaymentFromInvoice = `-- name: CreatePaymentFromInvoice :one
INSERT INTO app.payments
(subscription_id, amount_cents, currency, status, stripe_invoice_id, stripe_payment_intent_id, invoice_date, paid_at)
VALUES
($1::uuid, $2, $3,
 $4::app.payment_status, $5, $6, $7, $8)
RETURNING payment_id, subscription_id, delivery_id, amount_cents, currency, status, stripe_invoice_id, stripe_payment_intent_id, invoice_date, paid_at, created_at, updated_at
`

type CreatePaymentFromInvoiceParams struct {
	SubscriptionID        uuid.UUID        `db:"subscription_id" json:"subscriptionId"`
	AmountCents           int64            `db:"amount_cents" json:"amountCents"`
	Currency              string           `db:"currency" json:"currency"`
	Status                AppPaymentStatus `db:"status" json:"status"`
	StripeInvoiceID       sql.NullString   `db:"stripe_invoice_id" json:"stripeInvoiceId"`
	StripePaymentIntentID sql.NullString   `db:"stripe_payment_intent_id" json:"stripePaymentIntentId"`
	InvoiceDate           sql.NullTime     `db:"invoice_date" json:"invoiceDate"`
	PaidAt                sql.NullTime     `db:"paid_at" json:"paidAt"`
}

func (q *Queries) CreatePaymentFromInvoice(ctx context.Context, arg CreatePaymentFromInvoiceParams) (AppPayment, error) {
	row := q.db.QueryRowContext(ctx, createPaymentFromInvoice,
		arg.SubscriptionID,
		arg.AmountCents,
		arg.Currency,
		arg.Status,
		arg.StripeInvoiceID,
		arg.StripePaymentIntentID,
		arg.InvoiceDate,
		arg.PaidAt,
	)
	var i AppPayment
	err := row.Scan(
		&i.PaymentID,
		&i.SubscriptionID,
		&i.DeliveryID,
		&i.AmountCents,
		&i.Currency,
		&i.Status,
		&i.StripeInvoiceID,
		&i.StripePaymentIntentID,
		&i.InvoiceDate,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPaymentsBySubscription = `-- name: ListPaymentsBySubscription :many
SELECT payment_id, subscription_id, delivery_id, amount_cents, currency, status, stripe_invoice_id, stripe_payment_intent_id, invoice_date, paid_at, created_at, updated_at FROM app.payments
WHERE subscription_id = $1::uuid
ORDER BY created_at DESC
`

func (q *Queries) ListPaymentsBySubscription(ctx context.Context, subscriptionID uuid.UUID) ([]AppPayment, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentsBySubscription, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppPayment
	for rows.Next() {
		var i AppPayment
		if err := rows.Scan(
			&i.PaymentID,
			&i.SubscriptionID,
			&i.DeliveryID,
			&i.AmountCents,
			&i.Currency,
			&i.Status,
			&i.StripeInvoiceID,
			&i.StripePaymentIntentID,
			&i.InvoiceDate,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markPaymentPaid = `-- name: MarkPaymentPaid :one
UPDATE app.payments
SET status = 'paid',
    paid_at = COALESCE($1, now())
WHERE payment_id = $2::uuid
RETURNING payment_id, subscription_id, delivery_id, amount_cents, currency, status, stripe_invoice_id, stripe_payment_intent_id, invoice_date, paid_at, created_at, updated_at
`

type MarkPaymentPaidParams struct {
	PaidAt    sql.NullTime `db:"paid_at" json:"paidAt"`
	PaymentID uuid.UUID    `db:"payment_id" json:"paymentId"`
}

func (q *Queries) MarkPaymentPaid(ctx context.Context, arg MarkPaymentPaidParams) (AppPayment, error) {
	row := q.db.QueryRowContext(ctx, markPaymentPaid, arg.PaidAt, arg.PaymentID)
	var i AppPayment
	err := row.Scan(
		&i.PaymentID,
		&i.SubscriptionID,
		&i.DeliveryID,
		&i.AmountCents,
		&i.Currency,
		&i.Status,
		&i.StripeInvoiceID,
		&i.StripePaymentIntentID,
		&i.InvoiceDate,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
